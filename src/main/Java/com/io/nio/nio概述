Java NIO 由以下几个核心部分组成：
    Channels
    Buffers
    Selectors
    基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中
    Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现：
        FileChannel 从文件中读写数据
        DatagramChannel 能通过UDP读写网络中的数据
        SocketChannel 能通过TCP读写网络中的数据
        ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。
    正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。
    以下是Java NIO里关键的Buffer实现：
        ByteBuffer
        CharBuffer
        DoubleBuffer
        FloatBuffer
        IntBuffer
        LongBuffer
        ShortBuffer
    Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中
    要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，
    事件的例子有如新连接进来，数据接收等。

    capacity
    作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）
    才能继续写数据往里写数据。

    position
    当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。
    position最大可为capacity – 1. 当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，
    position向前移动到下一个可读的位置。

    limit
    在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。
    因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）

    equals()与compareTo()方法
    可以使用equals()和compareTo()方法两个Buffer。

    equals()
    当满足下列条件时，表示两个Buffer相等：
        有相同的类型（byte、char、int等）。
        Buffer中剩余的byte、char等的个数相等。
        Buffer中所有剩余的byte、char等都相同。
    如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。

    compareTo()方法
    compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：
        第一个不相等的元素小于另一个Buffer中对应的元素 。
        所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。

    Java NIO开始支持scatter/gather，scatter/gather用于描述从Channel（译者注：Channel在中文经常翻译为通道）中读取或者写入到Channel的操作。
    分散（scatter）从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。
    聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。

    Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，
    消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。

    注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。
    因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。
第六章 Selector
    Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。
    对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。

    与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。
    注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：
        Connect连接就绪
        Accept接收就绪
        Read读就绪
        Write写就绪

    SelectionKey
    在上一小节中，当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：

    interest集合
    ready集合
    Channel
    Selector
    附加的对象（可选）
    下面我会描述这些属性。

    interest集合
    就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：

    1
    int interestSet = selectionKey.interestOps();
    2

    3
    boolean isInterestedInAccept  = (interestSet & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；
    4
    boolean isInterestedInConnect = interestSet & SelectionKey.OP_CONNECT;
    5
    boolean isInterestedInRead    = interestSet & SelectionKey.OP_READ;
    6
    boolean isInterestedInWrite   = interestSet & SelectionKey.OP_WRITE;
    可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。

    ready集合
    ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：

    1
    int readySet = selectionKey.readyOps();
    可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：

    1
    selectionKey.isAcceptable();
    2
    selectionKey.isConnectable();
    3
    selectionKey.isReadable();
    4
    selectionKey.isWritable();
    Channel + Selector
    从SelectionKey访问Channel和Selector很简单。如下：

    1
    Channel  channel  = selectionKey.channel();
    2
    Selector selector = selectionKey.selector();
    附加的对象
    可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：

    1
    selectionKey.attach(theObject);
    2
    Object attachedObj = selectionKey.attachment();
    还可以在用register()方法向Selector注册Channel的时候附加对象。如：

    view sourceprint?
    1
    SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);



























