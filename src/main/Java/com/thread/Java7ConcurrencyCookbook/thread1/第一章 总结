1.线程管理（一）线程的创建和运行 one1
    当全部的线程执行结束时（更具体点，所有非守护线程结束时），Java程序就结束了。如果初始线程（执行main()方法的主线程）运行结束，其他的线程还是会继续执行直到执行完成。但是如果某
    个线程调用System.exit()指示终结程序，那么全部的线程都会结束执行。

2.线程管理（二）获取和设置线程信息 one2
    在Java中，线程只能有这6种中的一种状态： new, runnable, blocked, waiting, time waiting, 或 terminated.

3.线程管理（三）线程的中断 one3
    Java提供中断机制来通知线程表明我们想要结束它。中断机制的特性是线程需要检查是否被中断，而且还可以决定是否响应结束的请求。所以，线程可以忽略中断请求并且继续运行。
    Thread 类还有其他可以检查线程是否被中断的方法。例如，这个静态方法interrupted()能检查正在运行的线程是否被中断。
    isInterrupted()和interrupted() 方法有着很重要的区别。
    第一个不会改变interrupted属性值，但是第二个会设置成false。
    interrupted() 方法是一个静态方法，建议使用isInterrupted()方法。
    在之前提到的，线程是可以忽略中断指令的，但是并这不是我们所期望的行为。

4.线程管理（四）操作线程的中断机制 one4
    如果线程实现的是由复杂的算法分成的一些方法，或者它的方法有递归调用，那么我们可以用更好的机制来控制线程中断。为了这个Java提供了InterruptedException异常。
    当你检测到程序的中断并在run()方法内捕获，你可以抛这个异常。

5.线程的睡眠与恢复 one5
    当 Thread is是睡眠和中断的时候，那方法会立刻抛出InterruptedException异常并不会一直等到睡眠时间过去。睡眠的时候被中断会抛出异常

6.线程管理（六）等待线程的终结 one6
    Thread 类的join() 方法。当前线程调用某个线程的这个方法时，它会暂停当前线程，直到被调用线程执行完成。
    Java 提供2种形式的 join() 方法:
    join (long milliseconds)
    join (long milliseconds, long nanos)
    第一种join() 方法, 这方法让调用线程等待特定的毫秒数。例如，如果thread1对象使用代码thread2.join(1000), 那么线程 thread1暂停运行，直到以下其中一个条件发生：
    thread2 结束运行
    1000 毫秒过去了
    当其中一个条件为真时，join() 方法返回。
    第二个版本的 join() 方法和第一个很像，只不过它接收一个毫秒数和一个纳秒数作为参数。

7.线程管理（七）守护线程的创建和运行
    Java有一种特别的线程叫做守护线程。这种线程的优先级非常低，通常在程序里没有其他线程运行时才会执行它。当守护线程是程序里唯一在运行的线程时，JVM会结束守护线程并终止程序.
    其他线程执行完毕，程序结束！
    根据这些特点，守护线程通常用于在同一程序里给普通线程（也叫使用者线程）提供服务。它们通常无限循环的等待服务请求或执行线程任务。它们不能做重要的任务，因为我们不知道什么
    时候会被分配到CPU时间片，并且只要没有其他线程在运行，它们可能随时被终止。JAVA中最典型的这种类型代表就是垃圾回收器。只能在start() 方法之前可以调用 setDaemon() 方法。一旦线程运行了，就不能修改守护状态。
    可以使用 isDaemon() 方法来检查线程是否是守护线程（方法返回 true) 或者是使用者线程 (方法返回 false)。

8.线程管理（八）在线程里处理不受控制的异常
    thread.setUncaughtExceptionHandler(new ExceptionHandler());//设置非检查异常捕获类
    The Thread 类有其他相关方法可以处理未捕获的异常。静态方法 setDefaultUncaughtExceptionHandler() 为应用里的所有线程对象建立异常 handler 。
    当一个未捕捉的异常在线程里被抛出，JVM会寻找此异常的3种可能潜在的处理者（handler）
    首先, 它寻找这个未捕捉的线程对象的异常handle，如我们在在这个指南中学习的。如果这个handle 不存在，那么JVM会在线程对象的ThreadGroup里寻找非捕捉异常的handler，
    如在处理线程组内的不受控制异常里介绍的那样。如果此方法不存在，正如我们在这个指南中学习的，那么 JVM 会寻找默认非捕捉异常handle。如果没有一个handler存在, 那么 JVM会把异常的
    stack trace 写入操控台并结束任务。

9.线程管理（九）使用本地线程变量
    有时，你希望程序里的各个线程的属性不会被共享。 Java 并发 API提供了一个很清楚的机制叫本地线程变量。






























