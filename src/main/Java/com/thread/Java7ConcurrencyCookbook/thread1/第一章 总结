http://ifeve.com/java-7-concurrency-cookbook/ 参考解释
1.线程管理（一）线程的创建和运行 one1
    当全部的线程执行结束时（更具体点，所有非守护线程结束时），Java程序就结束了。如果初始线程（执行main()方法的主线程）运行结束，其他的线程还是会继续执行直到执行完成。但是如果某
    个线程调用System.exit()指示终结程序，那么全部的线程都会结束执行。

2.线程管理（二）获取和设置线程信息 one2
    在Java中，线程只能有这6种中的一种状态： new, runnable, blocked, waiting, time waiting, 或 terminated.

3.线程管理（三）线程的中断 one3
    Java提供中断机制来通知线程表明我们想要结束它。中断机制的特性是线程需要检查是否被中断，而且还可以决定是否响应结束的请求。所以，线程可以忽略中断请求并且继续运行。
    Thread 类还有其他可以检查线程是否被中断的方法。例如，这个静态方法interrupted()能检查正在运行的线程是否被中断。
    isInterrupted()和interrupted() 方法有着很重要的区别。
    第一个不会改变interrupted属性值，但是第二个会设置成false。
    interrupted() 方法是一个静态方法，建议使用isInterrupted()方法。
    在之前提到的，线程是可以忽略中断指令的，但是并这不是我们所期望的行为。

4.线程管理（四）操作线程的中断机制 one4
    如果线程实现的是由复杂的算法分成的一些方法，或者它的方法有递归调用，那么我们可以用更好的机制来控制线程中断。为了这个Java提供了InterruptedException异常。
    当你检测到程序的中断并在run()方法内捕获，你可以抛这个异常。

5.线程的睡眠与恢复 one5
    当 Thread is是睡眠和中断的时候，那方法会立刻抛出InterruptedException异常并不会一直等到睡眠时间过去。睡眠的时候被中断会抛出异常

6.线程管理（六）等待线程的终结 one6
    Thread 类的join() 方法。当前线程调用某个线程的这个方法时，它会暂停当前线程，直到被调用线程执行完成。
    Java 提供2种形式的 join() 方法:
    join (long milliseconds)
    join (long milliseconds, long nanos)
    第一种join() 方法, 这方法让调用线程等待特定的毫秒数。例如，如果thread1对象使用代码thread2.join(1000), 那么线程 thread1暂停运行，直到以下其中一个条件发生：
    thread2 结束运行
    1000 毫秒过去了
    当其中一个条件为真时，join() 方法返回。
    第二个版本的 join() 方法和第一个很像，只不过它接收一个毫秒数和一个纳秒数作为参数。

7.线程管理（七）守护线程的创建和运行   one7
    Java有一种特别的线程叫做守护线程。这种线程的优先级非常低，通常在程序里没有其他线程运行时才会执行它。当守护线程是程序里唯一在运行的线程时，JVM会结束守护线程并终止程序.
    其他线程执行完毕，程序结束！
    根据这些特点，守护线程通常用于在同一程序里给普通线程（也叫使用者线程）提供服务。它们通常无限循环的等待服务请求或执行线程任务。它们不能做重要的任务，因为我们不知道什么
    时候会被分配到CPU时间片，并且只要没有其他线程在运行，它们可能随时被终止。JAVA中最典型的这种类型代表就是垃圾回收器。只能在start() 方法之前可以调用 setDaemon() 方法。一旦线程运行了，就不能修改守护状态。
    可以使用 isDaemon() 方法来检查线程是否是守护线程（方法返回 true) 或者是使用者线程 (方法返回 false)。

8.线程管理（八）在线程里处理不受控制的异常   one8
    thread.setUncaughtExceptionHandler(new ExceptionHandler());//设置非检查异常捕获类
    The Thread 类有其他相关方法可以处理未捕获的异常。静态方法 setDefaultUncaughtExceptionHandler() 为应用里的所有线程对象建立异常 handler 。
    当一个未捕捉的异常在线程里被抛出，JVM会寻找此异常的3种可能潜在的处理者（handler）
    首先, 它寻找这个未捕捉的线程对象的异常handle，如我们在在这个指南中学习的。如果这个handle 不存在，那么JVM会在线程对象的ThreadGroup里寻找非捕捉异常的handler，
    如在处理线程组内的不受控制异常里介绍的那样。如果此方法不存在，正如我们在这个指南中学习的，那么 JVM 会寻找默认非捕捉异常handle。如果没有一个handler存在, 那么 JVM会把异常的
    stack trace 写入操控台并结束任务。

9.线程管理（九）使用本地线程变量       one9
    有时，你希望程序里的各个线程的属性不会被共享。 Java 并发 API提供了一个很清楚的机制叫本地线程变量。
    ThreadLocal,本地线程类还提供 remove() 方法，删除存储在线程本地变量里的值。Java 并发 API 包括 InheritableThreadLocal 类提供线程创建线程的值的遗传性 。如果线程A有一个本地线程
    变量，然后它创建了另一个线程B，那么线程B将有与A相同的本地线程变量值。 你可以覆盖 childValue() 方法来初始子线程的本地线程变量的值。 它接收父线程的本地线程变量作为参数。
    ThreadLocal有一个子类InheritableThreadLocal,可以把父线程的本地变量传递到子线程。

10.线程管理（十）线程组           one10
    Java并发 API里有个有趣的方法是把线程分组。这个方法允许我们按线程组作为一个单位来处理。例如，你有一些线程做着同样的任务，你想控制他们，无论多少线程还在运行，
    他们的状态会被一个call 中断，Java 提供 ThreadGroup 类来组织线程。 ThreadGroup 对象可以由 Thread 对象组成和由另外的 ThreadGroup 对象组成,生成线程树结构。

11.线程管理（十一）处理线程组内的不受控制异常        one11
    创建一个方法，捕获所有被ThreadGroup类的任何线程抛出的非捕捉异常。当运行这个例子，你会发现线程对象是如何抛出异常和其他被中断的。当一个非捕捉异常在线程内抛出，JVM会为这个异常寻找3种
    可能handlers。首先, 它寻找这个未捕捉的线程对象的异常handle，如在线程中处理不受控制异常中介绍的，如果这个handle 不存在，那么JVM会在线程对象的ThreadGroup里寻找非捕捉异常的
    handler，如我们在这个指南中学习的。如果此方法不存在，那么 JVM 会寻找默认非捕捉异常handle。如果没有 handlers存在, 那么 JVM会把异常的 stack trace 写入控制台并结束任务。

12.线程管理（十二）用线程工厂创建线程   one12
    Java提供一个接口， ThreadFactory 接口实现一个线程对象工厂。当我们储存创建的线程对象时，可以取个性化的名字。



























